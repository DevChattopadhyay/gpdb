create user new_user;
create table foo_rls ( a int, b int, c int) distributed by (a);
create table bar_rls ( p int, q int) distributed by (p);
insert into foo_rls select i,i*10,i*100 from generate_series(1,5)i;
insert into foo_rls values (NULL,50,500);;
insert into foo_rls values (NULL,60,NULL);
insert into foo_rls values (NULL,70,NULL);
insert into foo_rls values (NULL,NULL,600);
insert into foo_rls values (NULL,NULL,700);
vacuum analyze foo_rls;
grant select on foo_rls to new_user;
grant select on bar_rls to new_user;
alter table foo_rls enable row level security;

CREATE OR REPLACE FUNCTION leak_data(int) RETURNS boolean AS $$
BEGIN
  RAISE NOTICE 'Value of column is: %',$1;
RETURN true;
END;
$$ COST 0.0000001 LANGUAGE plpgsql;

-- Permissive policy
create policy p1 on foo_rls using (a * 10 = b and c > 300);
set session authorization new_user;
explain (costs off ) select * from foo_rls where leak_data(a);
select * from foo_rls where leak_data(a);
reset session authorization;
drop policy p1 on foo_rls;

-- All permissive policies which are applicable to a given query
-- will be combined together using the Boolean “OR” operator
create policy p1 on foo_rls as permissive for select using (a * 10 >= 30  );
create policy p2 on foo_rls as permissive for select
using (LEAST(a,b) >= 2);
set session authorization new_user;
explain (costs off )select * from foo_rls where leak_data(c);
select * from foo_rls where leak_data(c);
reset session authorization;
drop policy p1 on foo_rls;
drop policy p2 on foo_rls;

-- Restrictive policies
-- There needs to be at least one permissive policy to grant access to records
create policy p1 on foo_rls as restrictive for select using (a > 3);
create policy p2 on foo_rls as restrictive for select using (b > 35);
set session authorization new_user;
explain (costs off ) select * from foo_rls where leak_data(a);
reset session authorization ;
create policy p3 on foo_rls as permissive for select using (c % 100 = 0);
set session authorization new_user;
explain (costs off ) select * from foo_rls where leak_data(a);
select * from foo_rls where leak_data(a);
reset session authorization;
drop policy p1 on foo_rls;
drop policy p2 on foo_rls;
drop policy p3 on foo_rls;

-- The RTE of the relation containing security quals is present inside a
-- RTE_SUBQUERY rtekind
create policy p1 on foo_rls as permissive for select using (b + 1 = 4 );
create policy p2 on foo_rls as permissive for select using (b is distinct
from c);
set session authorization new_user;
explain (costs off ) select * from (select * from foo_rls) t1, bar_rls where
t1.a=bar_rls.p and bar_rls.q is null and leak_data(c);

-- The RTE of the relation containing security quals is present inside a
-- SUBLINK node
explain (costs off ) select * from bar_rls where bar_rls.p in (select a
from foo_rls where abs(a) >= 10 and leak_data(c)) and bar_rls.q is not null;

-- The RTE of the relation containing security quals is present inside a CTE
explain (costs off ) with cte as (select * from foo_rls where
a > LEAST(a,b)) select * from cte left join bar_rls on
cte.a=bar_rls.p and q = 10 and leak_data(cte.a);

reset session authorization;
drop policy p1 on foo_rls;
drop policy p2 on foo_rls;

-- ORCA will fallback to planner if SUBLINK is present inside a security qual
create policy p1 on foo_rls as permissive for select using (a in (select p
from bar_rls));
set session authorization new_user;
set optimizer_trace_fallback to on;
explain (costs off ) select * from foo_rls;
reset optimizer_trace_fallback;
reset session authorization;
drop policy p1 on foo_rls;

-- ORCA will not generate any index plans when row level security is enabled
-- for a relation
create policy p1 on foo_rls as permissive for select using (b = 10);
create index btindex on foo_rls using btree(a);
-- Index Scan is generated by ORCA when the owner of the table runs the query
set enable_seqscan to off;
explain (costs off) select * from foo_rls where a is null and b = 10;
-- Index Scan is not generated by ORCA when RLS enabled by ORCA
set session authorization new_user;
explain (costs off) select * from foo_rls where a is null;
reset session authorization;
-- Index Only Scan is generated by ORCA when the owner of the table runs the query
set optimizer_enable_indexscan to off;
explain (costs off) select a from foo_rls where a is null;
-- Index Only Scan is not generated by ORCA when RLS enabled
set session authorization new_user;
explain (costs off) select a from foo_rls where a is null;
reset session authorization;
set optimizer_enable_indexscan to on;
reset enable_seqscan;
drop policy p1 on foo_rls;
drop table foo_rls cascade;
drop table bar_rls cascade;

-------------------------
-- Partitioned Tables --
-------------------------
create table foo_part_rls ( a int, b int, c int) distributed by (a)
partition by range(b) (start(0) end(100) every(20), default partition other_part);
create table bar_part_rls ( p int, q int) distributed by (p) partition by range(q)
(start(0) end(100) every(20));
insert into foo_part_rls select i,i*10,i*100 from generate_series(1,5)i;
insert into foo_part_rls values (NULL,50,500);;
insert into foo_part_rls values (NULL,60,NULL);
insert into foo_part_rls values (NULL,70,NULL);
insert into foo_part_rls values (NULL,NULL,600);
insert into foo_part_rls values (NULL,NULL,700);
analyze foo_part_rls;
grant select on foo_part_rls to new_user;
grant select on bar_part_rls to new_user;
alter table foo_part_rls enable row level security;

-- Permissive policy
create policy p1 on foo_part_rls using (a * 10 = b and c > 300);
set session authorization new_user;
explain (costs off ) select * from foo_part_rls where leak_data(a);
select * from foo_part_rls where leak_data(a);
reset session authorization;
drop policy p1 on foo_part_rls;

-- All permissive policies which are applicable to a given query
-- will be combined together using the Boolean “OR” operator
create policy p1 on foo_part_rls as permissive for select using (a * 10 >= 30  );
create policy p2 on foo_part_rls as permissive for select
using (LEAST(a,b) >= 2);
set session authorization new_user;
explain (costs off )select * from foo_part_rls where leak_data(c);
select * from foo_part_rls where leak_data(c);
reset session authorization;
drop policy p1 on foo_part_rls;
drop policy p2 on foo_part_rls;

-- Restrictive policies
-- There needs to be at least one permissive policy to grant access to records
create policy p1 on foo_part_rls as restrictive for select using (a > 3);
create policy p2 on foo_part_rls as restrictive for select using (b > 35);
set session authorization new_user;
explain (costs off ) select * from foo_part_rls where leak_data(a);
reset session authorization ;
create policy p3 on foo_part_rls as permissive for select using (c % 100 = 0);
set session authorization new_user;
explain (costs off ) select * from foo_part_rls where leak_data(a);
select * from foo_part_rls where leak_data(a);
reset session authorization;
drop policy p1 on foo_part_rls;
drop policy p2 on foo_part_rls;
drop policy p3 on foo_part_rls;

-- The RTE of the relation containing security quals is present inside a
-- RTE_SUBQUERY rtekind
create policy p1 on foo_part_rls as permissive for select using (b + 1 = 4 );
create policy p2 on foo_part_rls as permissive for select using (b is distinct
from c);
set session authorization new_user;
explain (costs off ) select * from (select * from foo_part_rls) t1, bar_part_rls
where t1.a=bar_part_rls.p and bar_part_rls.q is not null and leak_data(c);

-- The RTE of the relation containing security quals is present inside a
-- SUBLINK node
explain (costs off ) select * from bar_part_rls where bar_part_rls.p in
(select a from foo_part_rls where abs(a) >= 10 and leak_data(c)) and
bar_part_rls.q is not null;

-- The RTE of the relation containing security quals is present inside a CTE
explain (costs off ) with cte as (select * from foo_part_rls where
a > LEAST(a,b)) select * from cte left join bar_part_rls on
cte.a=bar_part_rls.p and q = 10 and leak_data(cte.a);

reset session authorization;
drop policy p1 on foo_part_rls;
drop policy p2 on foo_part_rls;

-- ORCA will fallback to planner if SUBLINK is present inside a security qual
create policy p1 on foo_part_rls as permissive for select using (a in
(select p from bar_part_rls));
set session authorization new_user;
set optimizer_trace_fallback to on;
explain (costs off ) select * from foo_part_rls where foo_part_rls.b <15;
reset optimizer_trace_fallback;
reset session authorization;
drop policy p1 on foo_part_rls;

-- ORCA will not generate any index plans when row level security is enabled
-- for a relation
create policy p1 on foo_part_rls as permissive for select using (b = 10);
create index btindex on foo_part_rls using btree(a);
-- Dynamic Index Scan is generated by ORCA when the owner of the table runs
-- the query
set enable_seqscan to off;
explain (costs off) select * from foo_part_rls where a is null;
-- Dynamic Index Scan is not generated by ORCA when RLS is enabled
set session authorization new_user;
explain (costs off) select * from foo_part_rls where a is null;
reset session authorization;
reset enable_seqscan;
drop policy p1 on foo_part_rls;
drop table foo_part_rls cascade;
drop table bar_part_rls cascade;
drop function leak_data(int);
drop user new_user;
